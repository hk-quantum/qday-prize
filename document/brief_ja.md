# QDay Prize

## 量子回路の概要

[proos–zalka algorithm](https://arxiv.org/abs/quant-ph/0301141) をベースに以下の量子回路を作成して暗号を解読した。  
ECCのパラメータ $G$ と公開鍵 $Q=dG$ の $Q$ が与えられているため、$aG+bQ$をOracleとするショアのアルゴリズムを利用する。  
Oracleの詳細は[このレポート](https://github.com/hk-quantum/qday-prize/blob/v2.0.0/document/report_ja.md)を参照。

```
       ┌───┐                         ░ ┌──────┐┌─┐   
   qa: ┤ H ├────────■────────────────░─┤ QFT† ├┤M├───
       ├───┤        │                ░ ├──────┤└╥┘┌─┐
   qb: ┤ H ├────────■────────────────░─┤ QFT† ├─╫─┤M├
       └───┘┌───────┴────────┐┌─┐    ░ └──────┘ ║ └╥┘
   qx: ─────┤0               ├┤M├────░──────────╫──╫─
            │                │└╥┘┌─┐ ░          ║  ║ 
   qy: ─────┤1               ├─╫─┤M├─░──────────╫──╫─
            │  oracle: aG+bQ │ ║ └╥┘ ░          ║  ║ 
anc_0: ─────┤2               ├─╫──╫──░──────────╫──╫─
            │                │ ║  ║  ░          ║  ║ 
anc_1: ─────┤3               ├─╫──╫──░──────────╫──╫─
            └────────────────┘ ║  ║  ░          ║  ║ 
  a: 1/════════════════════════╬══╬═════════════╩══╬═
                               ║  ║             0  ║ 
  b: 1/════════════════════════╬══╬════════════════╩═
                               ║  ║                0 
 xy: 2/════════════════════════╩══╩══════════════════
                               0  1                  
```

量子回路の内容。

1. $qa$と$qb$は、それぞれ位数 $n$ のビット数を用意する
2. $qa$ と $qb$ にHゲートを適用して重ね合わせにする
3. $(qx, qy)=aG+bQ$となる量子回路を実行する
4. $(qx, qy)$ を測定して、1つの座標に固定化する
5. $qa$と$qb$にそれぞれ逆量子フーリエ変換（$QFT^†$）を適用する
6. 最後に$qa$と$qb$を測定する

測定した $a$ $b$ の値から以下の手順で秘密鍵を求める。

```math
\begin{align}
\text{len} &= \lfloor \log_2 n \rfloor \\
x &= \mathrm{floor}\!\Bigg(\frac{a \cdot n}{2^{\text{len}}}\Bigg), \mathrm{ceil}\!\Bigg(\frac{a \cdot n}{2^{\text{len}}}\Bigg) \\
y &= \mathrm{floor}\!\Bigg(\frac{b \cdot n}{2^{\text{len}}}\Bigg), \mathrm{ceil}\!\Bigg(\frac{b \cdot n}{2^{\text{len}}}\Bigg) \\d &= x^{-1} \cdot y \pmod{n}
\end{align}
```

1. 位数 $n$ のビット数を $len$ とする
2. $a$ の範囲を $2^{\text{len}}$ から $n$ に収めるためスケールする
3. $b$も同様にスケールする
4. $x$の逆元 $x^{-1}$ を求めつつ、$y$を掛け算することで秘密鍵の $d$ を求める

スケール時の丸め誤差を考慮して、$x$ $y$ それぞれについて切り捨てと切り上げの組み合わせ（４種類）を計算して、その中に秘密鍵を満たす値があるかどうかを判定している。

シミュレータでの実行により、正解を導くことのできる測定結果を得られるのは位数のビット数が小さい場合は60%〜70%程度となるが、位数のビット数が大きくなれば80%以上の確率で正解の測定結果を得られることが分かった。  
なお、量子コンピュータの実機（ibm_torino）では、ノイズの影響で結果はランダムとなってしまった。

## 必要となるリソース量

本作では、どのようなECCパラメータでも正しく動作するよう汎用的な量子回路で構成していることから、比較的多くの量子ゲートを必要としている。  
今回提示されている[ECC Curves and Keys](https://www.qdayprize.org/curves.txt)に対して、必要となる量子ビット数および量子ゲート数<sup>1</sup>は以下となる。  
また、iMac(Apple M1, Memory 16GB)で実行した際の、量子回路作成時間(circuit creation)およびシミュレーション時間(simulation)も参考として掲載する。

|ecc bits|prime|order|quantum bits|gate count<sup>1</sup>|circuit creation|simulation|
|--:|--:|--:|--:|--:|:--|:--|
|4|13|7|78|48261|1.6s|0.6s|
|6|43|31|152|452274|19.9s|10.7s|
|7|67|79|221|976577|48.8s|51.7s|
|8|163|139|276|2240599|126s|5m 27s|
|9|349|313|337|6347702|418s|1h 23m 54s|
|10|547|547|404|7000037|562s|9h 15m 51s|
|11|1051|1093|477|14783371|1355s|76h 44m 39s|

ビットコインで利用されている secp256k1 を解読するには、20万程度の量子ビットが必要だと見積もることができる。

---

<sup>1</sup> 複数の制御ビット付きゲートも1つの量子ゲートとしてカウントしているため、実際の量子コンピュータ向けにトランスパイルすると、量子ゲート数はもっと多くなる
