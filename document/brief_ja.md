# QDay Prize

## 量子回路の概要

[proos–zalka algorithm](https://arxiv.org/abs/quant-ph/0301141) をベースに以下の量子回路を作成して暗号を解読した。  
ECCのパラメータ $G$ と公開鍵 $Q=dG$ の $Q$ が与えられているため、$aG+bQ$をOracleとするショアのアルゴリズムを利用する。

```
       ┌───┐                         ░ ┌──────┐┌─┐   
   qa: ┤ H ├────────■────────────────░─┤ QFT† ├┤M├───
       ├───┤        │                ░ ├──────┤└╥┘┌─┐
   qb: ┤ H ├────────■────────────────░─┤ QFT† ├─╫─┤M├
       └───┘┌───────┴────────┐┌─┐    ░ └──────┘ ║ └╥┘
   qx: ─────┤0               ├┤M├────░──────────╫──╫─
            │                │└╥┘┌─┐ ░          ║  ║ 
   qy: ─────┤1               ├─╫─┤M├─░──────────╫──╫─
            │                │ ║ └╥┘ ░          ║  ║ 
anc_0: ─────┤2               ├─╫──╫──░──────────╫──╫─
            │  oracle: aG+bQ │ ║  ║  ░          ║  ║ 
anc_1: ─────┤3               ├─╫──╫──░──────────╫──╫─
            │                │ ║  ║  ░          ║  ║ 
anc_2: ─────┤4               ├─╫──╫──░──────────╫──╫─
            │                │ ║  ║  ░          ║  ║ 
anc_3: ─────┤5               ├─╫──╫──░──────────╫──╫─
            └────────────────┘ ║  ║  ░          ║  ║ 
  a: 1/════════════════════════╬══╬═════════════╩══╬═
                               ║  ║             0  ║ 
  b: 1/════════════════════════╬══╬════════════════╩═
                               ║  ║                0 
 xy: 2/════════════════════════╩══╩══════════════════
                               0  1                  
```

量子回路の内容。

- $qa$と$qb$は、それぞれ位数 $n$ のビット数を用意する
- $qa$ と $qb$ にHゲートを適用して重ね合わせにする
- $(qx, qy)=aG+bQ$となる量子回路を実行する
- $(qx, qy)$ を測定して、1つの座標に固定化する
- $qa$と$qb$にそれぞれ逆量子フーリエ変換（$QFT^†$）を適用する
- 最後に$qa$と$qb$を測定する

測定した $a$ $b$ の値から以下の手順で秘密鍵を求める。

```math
\begin{align}
\text{len} &= \lfloor \log_2 n \rfloor \\
x &= \mathrm{floor}\!\Bigg(\frac{a \cdot n}{2^{\text{len}}}\Bigg), \mathrm{ceil}\!\Bigg(\frac{a \cdot n}{2^{\text{len}}}\Bigg) \\
y &= \mathrm{floor}\!\Bigg(\frac{b \cdot n}{2^{\text{len}}}\Bigg), \mathrm{ceil}\!\Bigg(\frac{b \cdot n}{2^{\text{len}}}\Bigg) \\d &= x^{-1} \cdot y \pmod{n}
\end{align}
```

1. 位数 $n$ のビット数を $len$ とする
2. $a$ の範囲を $2^{\text{len}}$ から $n$ に収めるためスケールする
3. $b$も同様にスケールする
4. $x$の逆元 $x^{-1}=x^{n-2}$ を求めつつ、$y$を掛け算することで秘密鍵の $d$ を求める

スケール時の丸め誤差を考慮して、$x$ $y$ それぞれについて切り捨てと切り上げの組み合わせ（４種類）を計算して、その中に秘密鍵を満たす値があるかどうかを判定している。

正解を導くことのできる測定結果を得られるのは位数のビット数が小さい場合は60%〜70%程度となるが、位数のビット数が大きくなれば80%以上の確率で正解の測定結果を得られることが分かった。

## oracleの詳細

以下のように $a$ $b$ の各ビットを制御ビットとして、ECCにおける座標の足し算を繰り返していく。

```math
\ket{a_{n-1} ... a_2 a_1 a_0}G + \ket{b_{n-1} ... b_2 b_1 b_0}Q=\sum_{i=0}^{n-1} a_i \cdot G^{2^i}+\sum_{i=0}^{n-1} b_i \cdot Q^{2^i}
```

$G^{2^i}$や$Q^{2^i}$ は、古典計算の結果を量子回路へ適用させていく。

### 座標の足し算

以下の量子回路で1回の座標の足し算を行う。  
変数 $(qx, qy)$ に対して固定座標 P を足し算する。

```
   qx: ──────■────────X────────────■─────────
             │        │            │         
   qy: ──────■────────┼──X─────────■─────────
       ┌─────┴──────┐ │  │ ┌───────┴────────┐
   ox: ┤0           ├─X──┼─┤0               ├
       │            │    │ │                │
   oy: ┤1           ├────X─┤1               ├
       │            │      │                │
anc_0: ┤2 (qx,qy)+P ├──────┤2 inv (qx,qy)-P ├
       │            │      │                │
anc_1: ┤3           ├──────┤3               ├
       │            │      │                │
anc_2: ┤4           ├──────┤4               ├
       └────────────┘      └────────────────┘
```

- 入力 $(qx, qy)$ を元に $(qx, qy)+P$ を計算して $(ox, oy)$ に結果を格納する
- $(qx, qy)$ と $(ox, oy)$ をswapする
- $(ox, oy)=(qx, qy)-P$ となっているため、$(qx, qy)-P$ の逆回路を実行することで $(ox, oy)$ が打ち消されて $\ket{0...00}$ に戻る
- $(qx, qy)-P$は、量子回路としては $(qx, qy)+(-P)$ のように足し算回路を再利用する

この足し算回路では以下の ancilla ビットを用意した。

- 以下の状態を示すフラグ 3つ(1ビットずつ)
  - $(qx, qy)=O$
  - $(qx, qy)=-P$
  - $(qx, qy)=P$
- $dx:=(qx-Px) \mod{n}$
- $dy:=(qy-Py) \mod{n}$
- $dx^{-1}:=dx^{n-2} \mod{n}$
  - $dx^2,dx^4,dx^8...$ と $n-2$ の最上位ビットまでの冪乗を保持する量子ビットを追加で用意する
  - 一時計算用の量子レジスタも用意する
- $\lambda:=dx^{-1} \cdot dy \mod{n}$
- $\lambda \cdot ox$ ($oy$の計算用)
- 1ビットのキャリービット(各種計算で使う addr mod で利用)

## 必要となるリソース量

本作の量子回路で必要となる量子ビット数および量子ゲート数<sup>1</sup>は以下となる。

|ecc bits|prime|order|quantum bits|gate count<sup>1</sup>|
|--:|--:|--:|--:|--:|
|4|13|7|58|107164|
|6|43|31|98|894838|
|7|67|79|130|1772688|
|8|163|139|156|4213330|
|9|349|313|184|12567301|
|10|547|547|||
|11|1051|1093|246|28303785|

ビットコインで利用されている secp256k1 を解読するには、68000 以上の量子ビットと10億以上の量子ゲートが必要だと見積もることができる。  

---

<sup>1</sup> 複数の制御ビット付きゲートも1つの量子ゲートとしてカウントしているため、実際の量子コンピュータ向けにトランスパイルすると、量子ゲート数はもっと多くなる
